import express from "express";
import path from "path";
import session from "express-session";
import dotenv from "dotenv";
import cron from "node-cron";
import { v4 as uuidv4 } from "uuid";
import ejsMate from "ejs-mate";

dotenv.config();

type Image = {
  id: string;
  title: string;
  description: string;
  tags: string[];
  category: string;
  price: number;
  url: string;
  createdAt: Date;
};

type TrendLog = {
  timestamp: Date;
  sources: string[];
  topics: string[];
};

type SocialSettings = {
  instagram: boolean;
  facebook: boolean;
  tiktok: boolean;
  pinterest: boolean;
  twitter: boolean;
};

type Sale = {
  id: string;
  imageId: string;
  price: number;
  method: "paypal" | "card";
  buyerEmail: string;
  phone: string;
  timestamp: Date;
};

type MerchantSettings = {
  paypalEmail: string;
  cardNumber: string;
  smsNumber: string;
};

const app = express();
const PORT = process.env.PORT ? parseInt(process.env.PORT, 10) : 3000;
const ADMIN_EMAIL = process.env.ADMIN_EMAIL || "admin@example.com";
const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD || "change_me_password";
const ADMIN_CODE = process.env.ADMIN_CODE || "00000";
const SESSION_SECRET = process.env.SESSION_SECRET || "fluximart-session";

const images: Image[] = [];
const trendLogs: TrendLog[] = [];
let socialSettings: SocialSettings = {
  instagram: true,
  facebook: true,
  tiktok: true,
  pinterest: true,
  twitter: true,
};
const sales: Sale[] = [];
let merchantSettings: MerchantSettings = {
  paypalEmail: "",
  cardNumber: "",
  smsNumber: "",
};

app.engine("ejs", ejsMate);
app.set("view engine", "ejs");
app.set("views", path.join(process.cwd(), "src", "views"));
app.use(express.urlencoded({ extended: true }));
app.use(express.json());
app.use(
  session({
    secret: SESSION_SECRET,
    resave: false,
    saveUninitialized: false,
  })
);
app.use(express.static(path.join(process.cwd(), "src", "public")));

function pick<T>(arr: T[], n: number): T[] {
  const a = [...arr];
  const r: T[] = [];
  for (let i = 0; i < n && a.length > 0; i++) {
    const idx = Math.floor(Math.random() * a.length);
    r.push(a[idx]);
    a.splice(idx, 1);
  }
  return r;
}

function scanTrends(): string[] {
  const sources = [
    "Google Trends",
    "Instagram",
    "TikTok",
    "Pinterest",
    "Twitter",
    "Reddit",
    "News",
    "Gaming",
    "Tech",
    "Photography",
  ];
  const topicsPool = [
    "minimalist",
    "abstract",
    "wallpapers",
    "nature",
    "city",
    "portrait",
    "macro",
    "cyberpunk",
    "premium",
    "neon",
    "monochrome",
    "aerial",
    "wildlife",
    "architecture",
    "fantasy",
    "space",
    "sunset",
    "bokeh",
    "branding",
    "product",
  ];
  const topics = pick(topicsPool, 6);
  trendLogs.push({ timestamp: new Date(), sources, topics });
  return topics;
}

function generateImageFromTrend(topic: string): Image {
  const id = uuidv4();
  const title = `AI ${topic} ${id.slice(0, 6)}`;
  const description = `High-quality ${topic} image generated by AI.`;
  const tags = [topic, "ai", "trending", "snapstockx", "fluximart"];
  const category = topic;
  const price = Math.floor(Math.random() * 20) + 5;
  const url = `https://picsum.photos/seed/${id}/1200/800`;
  return {
    id,
    title,
    description,
    tags,
    category,
    price,
    url,
    createdAt: new Date(),
  };
}

function autoPost(image: Image): void {
  const caption = `${image.title} ${image.tags.map((t) => `#${t}`).join(" ")}`;
  if (socialSettings.instagram) console.log("Post to Instagram", caption);
  if (socialSettings.facebook) console.log("Post to Facebook", caption);
  if (socialSettings.tiktok) console.log("Post to TikTok", caption);
  if (socialSettings.pinterest) console.log("Post to Pinterest", caption);
  if (socialSettings.twitter) console.log("Post to Twitter", caption);
}

function generateDailyBatch(): Image[] {
  const topics = scanTrends();
  const batch: Image[] = [];
  for (let i = 0; i < 15; i++) {
    const topic = topics[Math.floor(Math.random() * topics.length)];
    const img = generateImageFromTrend(topic);
    images.unshift(img);
    batch.push(img);
    autoPost(img);
  }
  return batch;
}

function isAuthed(req: express.Request): boolean {
  return Boolean((req.session as any).userEmail);
}

function isAdmin(req: express.Request): boolean {
  return Boolean((req.session as any).isAdmin === true);
}

app.use((req, res, next) => {
  res.locals.authed = isAuthed(req);
  res.locals.admin = isAdmin(req);
  res.locals.brand = { site: "Fluximart", store: "SnapStockX" };
  next();
});

app.get("/", (req, res) => {
  const featured = images.slice(0, 12);
  res.render("home", { featured });
});

app.get("/marketplace", (req, res) => {
  const { q, tag, category, min, max } = req.query as Record<string, string>;
  let list = [...images];
  if (q) list = list.filter((i) => i.title.toLowerCase().includes(q.toLowerCase()));
  if (tag) list = list.filter((i) => i.tags.includes(tag));
  if (category) list = list.filter((i) => i.category === category);
  if (min) list = list.filter((i) => i.price >= Number(min));
  if (max) list = list.filter((i) => i.price <= Number(max));
  res.render("marketplace", { list, q: q || "", tag: tag || "", category: category || "", min: min || "", max: max || "" });
});

app.get("/image/:id", (req, res) => {
  const img = images.find((i) => i.id === req.params.id);
  if (!img) return res.status(404).send("Not found");
  const similar = images.filter((i) => i.category === img.category && i.id !== img.id).slice(0, 8);
  res.render("image", { img, similar });
});

app.get("/checkout/:id", (req, res) => {
  const img = images.find((i) => i.id === req.params.id);
  if (!img) return res.status(404).send("Not found");
  res.render("checkout", { img, merchantSettings });
});

app.get("/daily", (req, res) => {
  const today = new Date();
  const start = new Date(today.getFullYear(), today.getMonth(), today.getDate());
  const drops = images.filter((i) => i.createdAt >= start).slice(0, 15);
  res.render("daily", { drops, date: start });
});

app.get("/login", (req, res) => {
  res.render("login");
});

app.post("/login", (req, res) => {
  const email = String(req.body.email || "").trim().toLowerCase();
  (req.session as any).userEmail = email;
  return res.redirect("/account");
});

app.post("/logout", (req, res) => {
  req.session.destroy(() => {
    res.redirect("/");
  });
});

app.get("/account", (req, res) => {
  if (!isAuthed(req)) return res.redirect("/login");
  res.render("account");
});

app.get("/admin", (req, res) => {
  if (!isAdmin(req)) return res.redirect("/");
  const logs = trendLogs.slice(-10).reverse();
  const latest = images.slice(0, 30);
  const salesRecent = sales.slice(-20).reverse();
  const summary = aggregateSales(sales);
  res.render("admin", { logs, latest, socialSettings, merchantSettings, salesRecent, summary });
});

app.post("/admin/social", (req, res) => {
  if (!isAdmin(req)) return res.status(403).send("Forbidden");
  const { instagram, facebook, tiktok, pinterest, twitter } = req.body;
  socialSettings = {
    instagram: Boolean(instagram),
    facebook: Boolean(facebook),
    tiktok: Boolean(tiktok),
    pinterest: Boolean(pinterest),
    twitter: Boolean(twitter),
  };
  res.redirect("/admin");
});

app.post("/admin/generate", (req, res) => {
  if (!isAdmin(req)) return res.status(403).send("Forbidden");
  generateDailyBatch();
  res.redirect("/admin");
});

app.get("/admin-login", (req, res) => {
  res.render("admin_login");
});

app.post("/admin-login", (req, res) => {
  const { email, password, code } = req.body as Record<string, string>;
  const e = String(email || "").trim().toLowerCase();
  const p = String(password || "").trim();
  const c = String(code || "").trim();
  if (e === ADMIN_EMAIL && p === ADMIN_PASSWORD && c === ADMIN_CODE) {
    (req.session as any).isAdmin = true;
    return res.redirect("/admin");
  }
  return res.status(401).render("admin_login", { error: "Invalid credentials" });
});

app.post("/admin/settings", (req, res) => {
  if (!isAdmin(req)) return res.status(403).send("Forbidden");
  const { paypalEmail, cardNumber, smsNumber } = req.body as Record<string, string>;
  merchantSettings = {
    paypalEmail: String(paypalEmail || ""),
    cardNumber: String(cardNumber || ""),
    smsNumber: String(smsNumber || ""),
  };
  res.redirect("/admin");
});

app.post("/pay", (req, res) => {
  const { imageId, method, buyerEmail, phone } = req.body as Record<string, string>;
  const img = images.find((i) => i.id === imageId);
  if (!img) return res.status(404).send("Not found");
  const m = method === "paypal" ? "paypal" : "card";
  const sale: Sale = {
    id: uuidv4(),
    imageId: img.id,
    price: img.price,
    method: m,
    buyerEmail: String(buyerEmail || ""),
    phone: String(phone || ""),
    timestamp: new Date(),
  };
  sales.push(sale);
  console.log("SMS", sale.phone, "Paid", sale.price, "method", sale.method);
  return res.render("checkout_success", { img, sale });
});

app.post("/chat", (req, res) => {
  const { message } = req.body as { message: string };
  const m = String(message || "").toLowerCase();
  if (m.includes("refund")) return res.json({ reply: "Refunds are processed within 3-5 days." });
  if (m.includes("download")) return res.json({ reply: "Download links are available on your purchases page." });
  if (m.includes("price")) return res.json({ reply: "Prices vary per image category." });
  return res.json({ reply: "How can I help you today?" });
});

cron.schedule("0 0 * * *", () => {
  generateDailyBatch();
});

if (images.length === 0) {
  generateDailyBatch();
}

app.listen(PORT, () => {
  console.log(`Fluximart running on http://localhost:${PORT}`);
});

function aggregateSales(list: Sale[]) {
  const byDay: Record<string, { total: number; count: number }> = {};
  const byMethod: Record<string, { total: number; count: number }> = {};
  for (const s of list) {
    const d = s.timestamp.toISOString().slice(0, 10);
    byDay[d] = byDay[d] || { total: 0, count: 0 };
    byDay[d].total += s.price;
    byDay[d].count += 1;
    byMethod[s.method] = byMethod[s.method] || { total: 0, count: 0 };
    byMethod[s.method].total += s.price;
    byMethod[s.method].count += 1;
  }
  return { byDay, byMethod };
}
